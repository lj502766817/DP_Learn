#### SIFT说明

sift是一种用来找出图像中关键点以及关键点特征的算法.

##### 找到关键点

###### 初步筛选关键点

一个图像中的点是有很多的,那么一个点是如何可以被认为是关键点的呢.

那么,这个关键点他应该是能跨越图像尺度的,即,我们需要考虑一个图像在不同尺度下都存在的特征.例如,我们人眼去看一个图像,不管这个图像是放的近还是放的远,图像是很清晰或者是稍微模糊的,我们都是识别出这个图像.因此,我们在找关键点的时候就先需要对图像做一个高斯模糊来将图像变换到不同的尺度:

$$
\begin{aligned}
& L(x,y,\sigma)=G(x,y,\sigma)*L(x,y) \\
& \\
& 其中G(x,y,\sigma)为高斯函数: \\
& G(x,y,\sigma)={1\over 2\pi\sigma^2}e^{x^2+y^2\over2\sigma^2}\\
\end{aligned}
$$

其中$\sigma$ 决定了高斯函数对图像处理的平滑程度,$\sigma$ 越大,图像就越模糊

然后,我们还可以将图像的分辨率进行处理,结合高斯模糊,我们就能得到一个高斯模糊金字塔:
![多分辨率高斯模糊金字塔](https://user-images.githubusercontent.com/28779173/195509621-d7959fff-9fb9-4ee1-86c8-1560ad4b9313.jpg)
然后再对这个多分辨率的金字塔的每一层进行差分处理,即将高斯模糊处理后的图像依次逐对相减:

$$
D(x,y,\sigma)=[G(x,y,\sigma)-G(x,y,k\sigma)]*L(x,y)=L(x,y,k\sigma)-L(x,y,\sigma)
$$

得到一个高斯差分金字塔:
![高斯差分金字塔](https://user-images.githubusercontent.com/28779173/195510472-378e82af-1923-4bec-8c6c-c2aa7e975a51.jpg)
然后通过这个差分金字塔,我们就可以寻找尺度空间下的极值点,这个极值点的数值应该是大于或者小于空间中周围点的数值,即将像素点与它在图像域(同一个尺度空间)和尺度域(相邻的尺度空间)的临近像素点做比较.例如,我们选择的空间范围是3*3的话,这个检测的像素点会与它同平面的8个点,上平面9个点,下平面9个点做比较来看它是不是极值点.所以不会在最上面和最下面的尺度空间来筛选极值点

###### 精确找到关键点

经过前面的筛选,我们已经找到了备选的关键点了,但是由于这些关键点是差分空间里的离散关键点,因此有可能我们初步找到的关键点并不是空间中真正的极值点,而是极值点周围接近极值点的那些离散点.所以我们需要对差分空间的函数进行曲线的拟合来找到真正的极值点.(数学推导搞不定,以后再说)

###### 消除边界

为了避免我们找到的关键点在边界上,还要消除边界响应,这里用的是Hessian矩阵来消除边界点的:

$$
H(x,y)=
\left[
\begin{matrix}
D_{xx}(x,y) & D_{xy}(x,y) \\
D_{xy}(x,y) & D_{xx}(x,y)
\end{matrix}
\right]
\tag {$D_{xx}$表示对x求二阶偏导}
$$

将这个实对称阵进行对角化,我们可以得到:

$$
\left[
\begin{matrix}
\lambda_1 & 0 \\
0 & \lambda_2
\end{matrix}
\right]
$$

然后我们令$\alpha=\lambda_{max}$,$\beta=\lambda_{min}$,然后设$Tr(H)=\alpha+\beta$,$Det(H)=\alpha\beta$,用这两个函数进行相比:

$$
{Tr(H)^2\over Det(H)}={(\alpha+\beta)^2 \over \alpha\beta}={(\gamma\beta+\beta)^2 \over \gamma\beta^2}={(\gamma+1)^2 \over \gamma}<{(10+1)^2 \over 10} \tag{$\gamma$作者论文建议取10}
$$

如果式子成立的话,就认为这个是个边界,需要舍去这个关键点.

#### 得到关键点的特征

由于我们已经找到我们需要的特征点了,那么这个特征点在高斯金字塔$3\sigma$邻域空间内像素点梯度的模$m(x,y)$和方向$\theta(x,y)$也能得到了:

$$
\begin{aligned}
& m(x,y)=\sqrt{[L(x+1,y)-L(x-1,y)]^2+[L(x,y+1)-L(x,y-1)]^2} \\
& \theta(x,y)=arctan{L(x,y+1)-L(x,y-1) \over L(x+1,y)-L(x-1,y)} \\
\end{aligned}
$$

然后,我们将这些方向分成36份,用直方图去统计这些像素点方向和模(经过了高斯加权)的分布,选直方图最大的为主方向,然后用峰值80%的方向作为辅方向,所以,在一个尺度和位置上,可能有多个方向不同的关键点(代码中是直接复制峰值关键点,然后用辅方向去替换复制的方向).

为了保证特征矢量的旋转不变性,需要以特征点为中心将附近邻域的坐标旋转$\theta$ 角,即将保证坐标轴旋转到特征点的主方向:

$$
\left[
\begin{matrix}
x^\prime  \\
y^\prime 
\end{matrix}
\right]
=
\left[
\begin{matrix}
cos\theta & -sin\theta \\
sin\theta & cos\theta
\end{matrix}
\right]
\left[
\begin{matrix}
x  \\
y 
\end{matrix}
\right]
$$

旋转之后,我们以特征点为中心取8*8的窗口,求每个像素的梯度幅值和方向,然后利用高斯窗口对其进行加权运算，最后在每个4*4的小块上绘制8个方向的梯度直方图，计算每个梯度方向的累加值，即可形成一个种子点，即每个特征的由4个种子点组成，每个种子点有8个方向的向量信息(论文中建议对每个关键点使用4x4共16个种子点来描述，这样一个关键点就会产生128维的SIFT特征向量)。
